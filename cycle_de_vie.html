<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Le cycle de vie</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="style-cycle.css">
</head>

<body>

  <!-- Templates pour modales -->
  <template id="tmpl-devsecops">
    <p>DevSecOps (contraction de <strong>Development</strong>, <strong>Security</strong> et <strong>Operations</strong>) désigne une approche et une culture qui intègrent la sécurité dès le début et de façon continue dans le cycle de vie du développement logiciel.</p>
    <p><strong>Principe « shift-left »</strong> : au lieu de traiter la sécurité uniquement en fin de projet (phase « validation »), on la déplace vers la phase de conception et de développement.</p>
    <p><strong>Automatisation des contrôles</strong> : on intègre des outils de sécurité (SAST, DAST, analyse de dépendances, scans d’infrastructure as code) directement dans le pipeline CI/CD afin de détecter et corriger les vulnérabilités en continu.</p>
    <p><strong>Collaboration transversale</strong> : développeurs, équipes sécurité et opérations travaillent de concert, partagent des responsabilités et des indicateurs, et adoptent des processus communs (revues de code, tests de penetration automatisés, gestion des secrets, etc.).</p>
  </template>
  <template id="tmpl-observabilite">
    <p><strong>Logging structuré</strong> : JSON logs centralisés (ELK Stack).</p>
    <p><strong>Metric gathering</strong> : Prometheus + Grafana pour KPIs système et applicatifs.</p>
    <p><strong>Tracing distribué</strong> : OpenTelemetry, Jaeger pour diagnostiquer les latences en production.</p>
  </template>
  <template id="tmpl-qualite-tests">
    <p>La qualité logicielle désigne l’ensemble des pratiques et contrôles mis en œuvre pour garantir que l’application répond aux exigences fonctionnelles et non fonctionnelles, tout en restant fiable, maintenable et performante.</p>
    <p><strong>Tests unitaires</strong> : vérifient chaque unité de code (fonctions, méthodes) isolément pour s’assurer qu’elles se comportent comme prévu.</p>
    <p><strong>Tests d’intégration</strong> : valident la coopération entre plusieurs composants ou modules (API, bases de données, services externes).</p>
    <p><strong>Tests end-to-end (E2E)</strong> : simulent des parcours utilisateur complets (avec Cypress, Playwright…) pour s’assurer de la cohérence fonctionnelle de bout en bout.</p>
    <p><strong>Tests de performance</strong> : utilisent des outils comme k6 ou JMeter pour mesurer la charge, la latence et l’évolutivité sous stress.</p>
    <p><strong>Tests de non-régression</strong> : s’exécutent automatiquement à chaque changement (CI) pour détecter les effets secondaires indésirables.</p>
    <p>En intégrant ces tests dans un pipeline CI/CD, on s’assure d’une livraison continue sans régression et d’une montée en charge maîtrisée.</p>
  </template>
  <template id="tmpl-dette-technique">
    <p>La <strong>dette technique</strong> (ou <em>technical debt</em>) désigne l’ensemble des compromis faits volontairement (ou non) pendant le développement : choix rapides, raccourcis architecturaux, code non-optimisé ou absence de tests et documentation.</p>
    <p>Ces raccourcis permettent des livraisons plus rapides à court terme, mais génèrent un « intérêt » sous forme de complexité accrue, de bugs fréquents et de coûts de maintenance plus élevés.</p>
    <p><strong>Exemples :</strong></p>
    <ul>
      <li>Code dupliqué sans factorisation, nécessitant des correctifs multiples.</li>
      <li>Absence de tests automatisés, augmentant le risque de régression.</li>
      <li>Documentation incomplète, ralentissant l’onboarding de nouveaux développeurs.</li>
    </ul>
    <p><strong>Comment la gérer ?</strong> Mesurer avec SonarQube, allouer un pourcentage de chaque sprint au refactoring, maintenir une documentation vivante et pratiquer la revue de code.</p>
  </template>
  <template id="tmpl-cloud-scalabilite">
    <p>La <strong>cloud-native architecture</strong> permet de déployer et gérer vos applications de façon élastique et résiliente.</p>
    <p><strong>Infrastructure as Code (IaC)</strong> : décrivez et versionnez votre infrastructure comme du code (Terraform, Ansible, Pulumi).</p>
    <p><strong>Autoscaling</strong> : configurez des règles (CPU, RAM, queue length) pour ajuster le nombre de nœuds selon la demande.</p>
    <p><strong>Multi-région &amp; CDN</strong> : répartissez vos services pour garantir disponibilité et latence minimale.</p>
    <p><strong>Stratégies de déploiement</strong> (blue/green, canary) : minimise les interruptions et permet un rollback rapide.</p>
  </template>
  <template id="tmpl-accessibilite-ux">
    <p><strong>Audits WCAG</strong> : évalue la conformité aux standards A, AA, AAA via axe-core, Lighthouse.</p>
    <p><strong>Référentiel RGAA 4.1</strong> : norme française pour les services publics, alignée sur WCAG.</p>
    <p><strong>Loi n° 2005-102</strong> : impose l’accessibilité aux organisations publiques.</p>
    <p><strong>Score Lighthouse</strong> : audit automatisé en CI pour accessibilité et performance.</p>
    <p><strong>A/B testing &amp; heatmaps</strong> : valide UX et détecte zones d’abandon (Hotjar).</p>
  </template>
  <template id="tmpl-seo-pwa">
    <p><strong>SEO</strong> regroupe les techniques d’optimisation pour les moteurs de recherche : balises &lt;title&gt;, &lt;meta description&gt;, données structurées (JSON-LD), HTTPS, sitemap.xml, robots.txt et Core Web Vitals (LCP, FID, CLS).</p>
    <p><strong>PWA</strong> (Progressive Web App) offre une expérience native : manifest.json pour Add to Home Screen, Service Worker pour offline-first et push, stratégies de caching, HTTPS requis.</p>
    <p>Combiner SEO et PWA maximise votre portée organique et l’engagement utilisateur.</p>
  </template>
  <template id="tmpl-feedback-support">
    <p>Le <strong>feedback</strong> et le <strong>support</strong> constituent le lien direct avec vos utilisateurs finaux pour recueillir leurs retours et garantir leur satisfaction :</p>
    <ul>
      <li><strong>SLA & support dédié</strong> : définissez des niveaux de service (temps de réponse, heures de disponibilité) et mettez en place une équipe de support (helpdesk, chat, ticketing).</li>
      <li><strong>Base de connaissances & FAQ</strong> : centralisez guides, tutoriels, et bonnes pratiques pour permettre aux utilisateurs de résoudre eux-mêmes leurs problèmes.</li>
      <li><strong>Sondages in-app & NPS</strong> : intégrez des enquêtes de satisfaction (CSAT, NPS) directement dans l’application pour mesurer la fidélité et identifier les points d’amélioration.</li>
      <li><strong>Chatbots & assistance automatisée</strong> : déployez des assistants virtuels pour répondre aux questions fréquentes et orienter les utilisateurs vers le support humain si nécessaire.</li>
      <li><strong>Analytics & verbatim</strong> : analysez les données de tickets, les logs de chat et les commentaires pour détecter tendances, problèmes récurrents et opportunités d’optimisation.</li>
    </ul>
    <p>En structurant votre boucle de feedback et en automatisant les premiers niveaux de support, vous améliorez l’expérience utilisateur tout en réduisant les coûts de maintenance et de support.</p>
  </template>
  <template id="tmpl-fin-vie">
    <p>La <strong>phase de fin de vie</strong> intervient lorsque l’application ou un service n’est plus maintenu ou doit être remplacé :</p>
    <ul>
      <li><strong>Plan de migration</strong> : élaborez un chemin de transition pour déplacer utilisateurs et données vers la nouvelle solution sans interruption de service.</li>
      <li><strong>Archivage sécurisé</strong> : définissez une politique de rétention des données, cryptez et stockez les archives dans un système conforme aux normes légales (RGPD, ISO 27001).</li>
      <li><strong>Audit post-mortem</strong> : analysez le projet (succès, échecs, enseignements) pour capitaliser sur les bonnes pratiques et éviter les erreurs futures.</li>
      <li><strong>Communication</strong> : informez les parties prenantes et utilisateurs finaux des échéances, modalités de transition et points de contact.</li>
      <li><strong>Nettoyage des ressources</strong> : supprimez les environnements de test et de production obsolètes pour libérer les ressources et réduire les coûts.</li>
    </ul>
    <p>En prévoyant dès la conception une stratégie de fin de vie, vous garantissez une transition fluide, une conformité réglementaire et une optimisation des ressources.</p>
  </template>




    <header class="fixed-top">
        <!-- Barre de navigation principale -->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark py-2">
            <div class="container-fluid d-flex align-items-center">
                <!-- Logo -->
                <a class="navbar-brand" href="index.html">Vitrine C8</a>

                <!-- Texte "INTRODUCTION" aligné à gauche avec un espace de 50px -->
                <span class="text-white fw-bold fs-4 ms-4">CYCLE DE VIE</span>

                <!-- Bouton Burger -->
                <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
                    aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Menu principal -->
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="documentation.html">Documentation</a></li>
                        <li class="nav-item"><a class="nav-link" href="cycle_de_vie.html">Cycle de vie</a></li>
                        <li class="nav-item"><a class="nav-link" href="versioning.html">Versioning</a></li>
                        <li class="nav-item"><a class="nav-link" href="deploiement.html">Déploiement</a></li>
                        <li class="nav-item"><a class="nav-link" href="conclusion.html">Conclusion</a></li>
                    </ul>
                </div>
            </div>
        </nav>

        <!-- Seconde barre de navigation plus mince (fixe, sans interaction avec le burger) -->
        <nav class="sub-navbar navbar navbar-expand bg-secondary py-1">
            <div class="container d-flex justify-content-center">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link text-white" href="#item1">Introduction</a></li>
                    <li class="nav-item"><a class="nav-link text-white" href="#item1b">Processus transverses</a></li>
                    <li class="nav-item"><a class="nav-link text-white" href="#item1c">Métiers</a></li>
                    <li class="nav-item"><a class="nav-link text-white" href="#item2">Grandes étapes</a></li>
                    <li class="nav-item"><a class="nav-link text-white" href="#item3">Cas pratique</a></li>
                    <li class="nav-item"><a class="nav-link text-white" href="#item4">Conclusion</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main class="container mt-5">

        <article aria-label="headings">
            <h1>Cycle de vie d'une application web</h1>
        </article>
        <br id="item1"><br>

        <!-- Section Contexte et enjeux -->
        <section id="contexte-enjeux" class="section">
            <h2>Introduction : Contexte et enjeux</h2>

            <p>
                Dans un environnement numérique en constante évolution, la réussite d’une application web ne se limite
                pas à la qualité de son code : elle dépend avant tout de la manière dont on envisage et pilote chaque
                étape de son existence, depuis la compréhension des besoins jusqu’à son éventuel retrait de service. Le
                cycle de vie d’une application web constitue ainsi un cadre méthodologique essentiel, qui garantit non
                seulement une conception robuste et sécurisée, mais aussi une évolutivité maîtrisée et une rentabilité
                maximale.
            </p>
            <p>
                Ce document s’adresse aux équipes de projet — chefs de produit, architectes, développeurs, DevOps,
                testeurs et UX/UI designers — souhaitant disposer d’une vision complète et intégrée des différentes
                phases du cycle de vie, ainsi que des bonnes pratiques et des indicateurs à suivre pour piloter
                efficacement leur projet. Nous y définissons le périmètre fonctionnel (front-end, back-end,
                infrastructure, qualité), le périmètre organisationnel (parties prenantes, livrables), et nous
                illustrons comment aligner les objectifs métiers et les indicateurs clés de performance (KPI) avec les
                exigences non-fonctionnelles (scalabilité, performance, sécurité, observabilité).
            </p>
            <p>
                Cette introduction pose les fondations :
            </p>

            <h3>1. Définition et périmètre</h3>
            <h4>Définition</h4>
            <p>
                Le cycle de vie d’une application web regroupe l’ensemble des étapes, de la conception initiale à la
                mise hors service, nécessaires pour garantir qu’un service en ligne répond durablement aux besoins
                métiers et utilisateurs.
            </p>
            <!-- Périmètre fonctionnel en cards -->
            <h4>Périmètre fonctionnel</h4>
            <div class="roles-grid">
                <div class="role-card">
                    <h3>Front-end</h3>
                    <p>Expérience utilisateur, interfaces graphiques, accessibilité.</p>
                </div>
                <div class="role-card">
                    <h3>Back-end</h3>
                    <p>API, logique métier, persistance des données.</p>
                </div>
                <div class="role-card">
                    <h3>Infrastructure</h3>
                    <p>Serveurs, conteneurs, plateformes cloud.</p>
                </div>
                <div class="role-card">
                    <h3>Qualité</h3>
                    <p>Tests (unitaires, fonctionnels, performance), sécurité.</p>
                </div>
            </div>
            <br>
            <!-- Périmètre organisationnel en cards -->
            <h4>Périmètre organisationnel</h4>
            <div class="roles-grid">
                <div class="role-card">
                    <h3>Parties prenantes</h3>
                    <p>Chefs de projet, product owners, équipes design, développement, DevOps et support.</p>
                </div>
                <div class="role-card">
                    <h3>Artefacts clés</h3>
                    <p>Cahier des charges, user stories, schémas d’architecture, pipelines CI/CD, documentation vivante.
                    </p>
                </div>
            </div>
            <br>
            <p>
                <strong>Exemple illustratif :</strong> pour un portail e‑commerce, le périmètre couvre le parcours
                visiteur (catalogue, panier), l’admin‑panel (gestion des produits), l’API de paiement, l’infrastructure
                (load‑balancer, base de données répliquée) et la conformité RGPD.
            </p>

            <h3>2. Objectifs métiers et KPI associés</h3>
            <p>
                Pour chaque projet, formaliser les objectifs métier et définir des indicateurs de performance (<abbr
                    title="Key Performance Indicator">KPI</abbr>) permet un pilotage transparent et orienté résultats.
            </p>
            <p>
                Un KPI (Key Performance Indicator) est une métrique quantifiable qui permet de mesurer l’efficacité
                d’une action, d’un projet ou d’un processus par rapport à un objectif défini.
            </p><br>

            <!-- Bloc vidéo responsive -->
            <div class="video-wrapper">
                <iframe src="https://www.youtube.com/embed/Hag78PCXn9Y" title="Le Key Performance Indicator (KPI)"
                    frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen>
                </iframe>
            </div>

            <br>
            <p>
                Ci‑dessous un tableau de KPIs généraux, applicable à tout type d’application web :
            </p>

            <div class="table-responsive">
                <table class="kpi-table">
                    <thead>
                        <tr>
                            <th>Objectif métier</th>
                            <th>KPI principal</th>
                            <th>Commentaire</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Améliorer l’engagement utilisateur</td>
                            <td>Taux d’utilisateurs actifs (DAU/MAU)</td>
                            <td>Ratio utilisateurs quotidiens / mensuels, indicateur de rétention</td>
                        </tr>
                        <tr>
                            <td>Optimiser la performance</td>
                            <td>Temps de chargement moyen (TTFB ou FCP)</td>
                            <td>Doit rester &lt; 300 ms pour le TTFB et &lt; 1 s pour le FCP</td>
                        </tr>
                        <tr>
                            <td>Garantir la fiabilité</td>
                            <td>Taux de disponibilité (uptime)</td>
                            <td>&ge; 99,9 % (SLA), suivi continu via monitoring</td>
                        </tr>
                        <tr>
                            <td>Réduire les erreurs</td>
                            <td>Nombre d’erreurs critiques (5xx, JS)</td>
                            <td>MTTR (Mean Time To Repair) : objectif &lt; 30 min</td>
                        </tr>
                        <tr>
                            <td>Assurer la sécurité</td>
                            <td>Nombre de vulnérabilités critiques</td>
                            <td>Scanner SAST/DAST mensuel, objectif 0 critiques ouvertes</td>
                        </tr>
                        <tr>
                            <td>Optimiser les coûts</td>
                            <td>Coût infra par utilisateur</td>
                            <td>Suivi via facturation cloud, comparer €/DAU</td>
                        </tr>
                        <tr>
                            <td>Améliorer la qualité du code</td>
                            <td>Taux de couverture de tests (%)</td>
                            <td>Cible &ge; 80 % (unitaires + intégration)</td>
                        </tr>
                        <tr>
                            <td>Renforcer l’accessibilité</td>
                            <td>Score de conformité WCAG (%)</td>
                            <td>Audit trimestriel, viser &ge; 90 %</td>
                        </tr>
                        <tr>
                            <td>Accélérer le déploiement</td>
                            <td>Lead time for changes</td>
                            <td>Temps médian entre commit et prod, objectif &lt; 1 h</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p class="astuce">
                <strong>Astuce :</strong> pour chaque KPI, définissez un seuil chiffré clair (ex. uptime &ge; 99,9 %,
                couverture &ge; 80 %) et une fréquence de suivi (quotidien, hebdomadaire, mensuel).
            </p>

            <h3>3. Enjeux techniques (scalabilité, performance, sécurité…)</h3>
            <p>
                Les défis techniques garantissent que l’application reste fiable et maintenable face à la croissance et
                aux menaces.
            </p>

            <h4>Scalabilité</h4>
            <ul>
                <li><strong>Horizontale</strong> : ajouter des instances de service (containers, VM) derrière un
                    load-balancer.</li>
                <li><strong>Verticale</strong> : renforcer les ressources (CPU, RAM) d’un serveur.</li>
            </ul>
            <p><strong>Exemple :</strong> passer de 2 à 20 nœuds Docker avec Kubernetes pour absorber un pic de trafic
                pendant les soldes.</p>

            <h4>Performance</h4>
            <ul>
                <li><strong>Temps de chargement</strong> : optimiser les assets (minification JS/CSS, lazy-loading
                    images).</li>
                <li><strong>Caching</strong> : front-end (Service Workers), back-end (Redis, Varnish).</li>
                <li><strong>Tests de charge</strong> : utiliser JMeter ou k6 pour simuler 1 000 utilisateurs simultanés.
                </li>
            </ul>

            <h4>Sécurité</h4>
            <ul>
                <li><strong>Authentification & autorisation</strong> : OAuth2, JWT, RBAC.</li>
                <li><strong>Protection des API</strong> : rate-limiting, WAF (Web Application Firewall).</li>
                <li><strong>Chiffrement</strong> : TLS 1.2+, chiffrement des données au repos (AES-256).</li>
                <li><strong>Audit & compliance</strong> : scans automatisés de vulnérabilités (SAST/DAST), revue
                    périodique des dépendances (Dependabot).</li>
            </ul>

            <h4>Résilience et robustesse</h4>
            <ul>
                <li><strong>Haute disponibilité (HA)</strong> : déploiement multi-zone / multi-région, failover
                    automatique.</li>
                <li><strong>Tolérance aux pannes</strong> : stratégies de retry, circuit breaker pattern.</li>
            </ul>


        </section>

<!-- Section Processus transverses -->
<section id="item1b" class="section my-5">
    <h2>Processus transverses & bonnes pratiques</h2><br>
    <div class="roles-grid">
      <div class="role-card clickable" data-title="DevSecOps" data-template="devsecops">
        <h3>DevSecOps</h3>
        <p>Culture sécurité continue…</p>
      </div>
      <div class="role-card clickable" data-title="Observabilité" data-template="observabilite">
        <h3>Observabilité</h3>
        <p>Logs, métriques, tracing…</p>
      </div>
      <div class="role-card clickable" data-title="Qualité & tests" data-template="qualite-tests">
        <h3>Qualité & tests</h3>
        <p>Unitaires, E2E, performance…</p>
      </div>
      <div class="role-card clickable" data-title="Dette technique" data-template="dette-technique">
        <h3>Dette technique</h3>
        <p>Compromis, refactoring…</p>
      </div>
      <div class="role-card clickable" data-title="Cloud & Scalabilité" data-template="cloud-scalabilite">
        <h3>Cloud & Scalabilité</h3>
        <p>IaC, autoscaling…</p>
      </div>
      <div class="role-card clickable" data-title="Accessibilité & UX" data-template="accessibilite-ux">
        <h3>Accessibilité & UX</h3>
        <p>WCAG, RGAA, heatmaps…</p>
      </div>
      <div class="role-card clickable" data-title="SEO & PWA" data-template="seo-pwa">
        <h3>SEO &amp; PWA</h3>
        <p>SEO, PWA…</p>
      </div>
      <div class="role-card clickable" data-title="Feedback & Support" data-template="feedback-support">
        <h3>Feedback & Support</h3>
        <p>SLA, chatbots…</p>
      </div>
      <div class="role-card clickable" data-title="Fin de vie" data-template="fin-vie">
        <h3>Fin de vie</h3>
        <p>Migration, archivage…</p>
      </div>
    </div>
  </section>


    </div>
    <p> À l’issue de cette mise en contexte, nous détaillerons les <strong>grandes étapes du cycle de vie. Mais
            voyons d'abord quels sont les métiers impliqués dans le cycle de vie.</strong>.
    </p>
  </section>
  
  


  <!-- Modale unique -->
  <div class="modal fade" id="processModal" tabindex="-1" aria-labelledby="processModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="processModalLabel">Titre</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
        </div>
        <div class="modal-body">
          <div id="processModalContent"></div>
        </div>
      </div>
    </div>
  </div>










<!-- ROLES ET RESPONSABILITES -->
<section id="item1c" class="section my-5">
    <h2>Métiers : Rôles et Responsabilités</h2><br>
  
    <!-- illustration -->
    <div class="role-illustration">
      <img src="img/img-cycle/brainStorming.jpg" alt="Brainstorming cycle de vie" class="img-fluid" />
    </div>
    <br>
  
    <!-- grille de cards -->
    <div class="roles-grid">
      <div class="role-card">
        <h3>MOA (Maîtrise d’Ouvrage)</h3>
        <p>Définit les besoins métier, valide les objectifs et les livrables auprès des parties prenantes.</p>
      </div>
      <div class="role-card">
        <h3>AMOA (Assistance à Maîtrise d’Ouvrage)</h3>
        <p>Accompagne la MOA, organise les workshops, rédige le cahier des charges et priorise les fonctionnalités.</p>
      </div>
      <div class="role-card">
        <h3>MOE (Maîtrise d’Œuvre)</h3>
        <p>Évalue la faisabilité technique, propose l’architecture et planifie la réalisation du projet.</p>
      </div>
      <div class="role-card">
        <h3>Chef de projet</h3>
        <p>Responsable de la gestion des coûts et de l’efficacité des ressources, il veille à ce que les
        projets contribuent positivement au CA en respectant délais et budgets.</p>
      </div>
      <div class="role-card">
        <h3>UX Designer</h3>
        <p>Améliore l’expérience utilisateur pour augmenter la satisfaction, la fidélisation et les
        conversions, réduisant le taux d’abandon.</p>
      </div>
      <div class="role-card">
        <h3>UI Designer</h3>
        <p>Optimise l’esthétique et l’ergonomie de l’interface, encourage l’engagement et influence la
        perception de valeur du produit.</p>
      </div>
      <div class="role-card">
        <h3>Architecte logiciel</h3>
        <p>Conçoit des architectures performantes et évolutives, réduisant les coûts de maintenance et
        améliorant la rentabilité.</p>
      </div>
      <div class="role-card">
        <h3>Développeur</h3>
        <p>Implémente les fonctionnalités et optimise les performances, garantissant un produit solide
        susceptible de générer des revenus.</p>
      </div>
      <div class="role-card">
        <h3>Testeur QA</h3>
        <p>Assure la qualité et la fiabilité via tests, réduisant les coûts de correction de bugs et
        protégeant le CA.</p>
      </div>
      <div class="role-card">
        <h3>DevOps</h3>
        <p>Automatise les déploiements et gère l’infrastructure pour améliorer disponibilité et rapidité des
        mises à jour.</p>
      </div>
      <div class="role-card">
        <h3>Administrateur système</h3>
        <p>Garantit la sécurité et la stabilité des serveurs et bases de données pour éviter les
        interruptions de service.</p>
      </div>
      <div class="role-card">
        <h3>Support technique</h3>
        <p>Fournit une assistance client efficace, améliorant la fidélisation et réduisant le churn.</p>
      </div>
      <div class="role-card">
        <h3>Équipes légales</h3>
        <p>Veillent à la conformité RGPD et aux contrats, protégeant l’entreprise des risques juridiques et
        amendes.</p>
      </div>
    </div>
  </section>
  





        <div class="scrollable-container" id="item2">

            <article>
                <br>
                <h2>Les grandes étapes du cycle de vie</h2><br>
                <div class="timeline">
                    <div class="timeline-item" data-target="analyse">Analyse des besoins</div>
                    <div class="timeline-item" data-target="conception">Conception et planification</div>
                    <div class="timeline-item" data-target="developpement">Développement</div>
                    <div class="timeline-item" data-target="deploiement">Déploiement</div>
                    <div class="timeline-item" data-target="maintenance">Maintenance et évolutions</div>
                    <div class="timeline-item" data-target="decommissionnement">Décommissionnement<div class="triangle">
                        </div>
                    </div>
                </div>

                <br>

<!-- Analyse des besoins -->
<section id="analyse" class="my-5">
    <h2>
      <img src="img/img-cycle/microscope.png" alt="icon analyse" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Analyse des besoins
    </h2>
  
    <p>
      La phase d’analyse des besoins est cruciale : elle permet de définir précisément <strong>ce que doit faire</strong> votre application et <strong>pour qui</strong>. Vous y identifiez à la fois les attentes métier, les cas d’usage utilisateur et les contraintes techniques.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Comprendre le contexte</strong> : marché, concurrents, processus internes.</li>
      <li><strong>Cerner le public cible</strong> : typologie d’utilisateurs, niveaux de compétence, dispositifs utilisés.</li>
      <li><strong>Définir les fonctionnalités clés</strong> : parcours utilisateur prioritaires (MVP).</li>
      <li><strong>Recenser les exigences non-fonctionnelles</strong> : performance, sécurité, accessibilité.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>Ateliers de cadrage</strong> avec la MOA/AMOA et la MOE pour aligner vision métier et faisabilité technique.</li>
      <li><strong>Interviews utilisateurs</strong> (5–10 entretiens) pour recueillir les besoins et frustrations réels.</li>
      <li><strong>Cartographie des parcours</strong> (user journeys) pour repérer les points de friction.</li>
      <li><strong>Rédaction de user stories</strong> avec critères d’acceptation (format “En tant que…, je veux…, afin de…”).</li>
      <li><strong>Priorisation MoSCoW</strong> (Must, Should, Could, Won’t) pour planifier le MVP et les itérations suivantes.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>FigJam/Miro</strong> pour les workshops et la co-création de cartes d’empathie.</li>
      <li><strong>Typeform</strong> ou <strong>Google Forms</strong> pour les sondages rapides.</li>
      <li><strong>Figma</strong> ou <strong>Adobe XD</strong> pour les wireframes et prototypes basse fidélité.</li>
      <li><strong>Jira</strong> / <strong>Azure DevOps</strong> / <strong>Trello</strong> pour gérer backlog et user stories.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Cahier des charges fonctionnel</strong> ou document de vision produit.</li>
      <li><strong>User stories</strong> et backlog initial priorisé.</li>
      <li><strong>Wireframes basse fidélité</strong> pour valider la disposition des écrans.</li>
      <li><strong>Diagramme de cas d’usage</strong> (UML) ou flux utilisateur.</li>
      <li><strong>Spécifications non-fonctionnelles</strong> (SLA, contraintes de sécurité, compatibilité navigateurs).</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Impliquer régulièrement les utilisateurs finaux pour valider vos hypothèses.</li>
      <li>Documenter chaque atelier et mettre à jour le backlog dès que de nouveaux besoins émergent.</li>
      <li>Ne pas surcharger le MVP : rester focus sur le cœur de valeur métier.</li>
      <li>Réutiliser des composants design system pour accélérer la phase prototype.</li>
      <li>Planifier une phase de revue avant de passer à la conception détaillée.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>MOA</strong> (Maîtrise d’Ouvrage) : formalise les besoins métier et valide les livrables.<br>
      • <strong>AMOA</strong> (Assistance à Maîtrise d’Ouvrage) : accompagne la MOA dans les ateliers, la rédaction du cahier des charges et la priorisation.<br>
      • <strong>MOE</strong> (Maîtrise d’Œuvre) : évalue la faisabilité technique et planifie la réalisation.<br>
      • <strong>UX/UI Designers</strong>, <strong>Business Analyst</strong>, <strong>Développeurs</strong>.
    </p>
  </section>
  
  

<!-- Conception et planification -->
<section id="conception" class="my-5">
    <h2>
      <img src="img/img-cycle/time-and-calendar.png" alt="icon conception" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Conception et planification
    </h2>
  
    <p>
      Après avoir validé les besoins, la phase de conception formalise la solution technique et organise le travail à venir. On y crée des maquettes, on choisit les technologies, et on définit l’architecture logicielle et infrastructurelle pour garantir performance, évolutivité et maintenabilité.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Valider l’ergonomie</strong> : prototypes basse et haute fidélité pour tester le parcours utilisateur.</li>
      <li><strong>Choisir la stack technique</strong> : langages, frameworks, bases de données, services tiers.</li>
      <li><strong>Définir l’architecture</strong> : micro-services vs monolithe, schéma de bases, API, sécurité.</li>
      <li><strong>Planifier les sprints</strong> : découpage en itérations, jalons, points de contrôle.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>Workshops UX</strong> avec MOA/AMOA et UX Designers pour valider les wireframes et prototypes.</li>
      <li><strong>Sessions d’architecture</strong> avec MOE et architectes pour définir les composants et leurs interactions.</li>
      <li><strong>Backlog grooming</strong> : affiner et estimer les user stories en équipe pluridisciplinaire.</li>
      <li><strong>Planification Agile</strong> (Sprint Planning, Definition of Done) pour organiser les itérations.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>Figma</strong> ou <strong>Sketch</strong> pour les maquettes et prototypes interactifs.</li>
      <li><strong>Lucidchart</strong> ou <strong>Draw.io</strong> pour les diagrammes d’architecture et flux de données.</li>
      <li><strong>Jira</strong> / <strong>Azure DevOps</strong> pour gérer le backlog et suivre l’avancement.</li>
      <li><strong>Confluence</strong> ou <strong>Notion</strong> pour centraliser la documentation et les décisions techniques.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Prototypes UI/UX</strong> validés par les parties prenantes.</li>
      <li><strong>Schémas d’architecture</strong> (UML, C4) et diagrammes de séquence.</li>
      <li><strong>Backlog priorisé</strong> avec user stories, tâches et estimations.</li>
      <li><strong>Plan de release</strong> et roadmap projet.</li>
      <li><strong>Spécifications techniques</strong> (API contracts, contraintes non-fonctionnelles, SLAs).</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Impliquer MOA/AMOA et MOE dès le début pour aligner vision fonctionnelle et contraintes techniques.</li>
      <li>Prototyper rapidement pour tester les hypothèses UX avant d’investir dans le développement.</li>
      <li>Documenter les décisions d’architecture et mettre à jour en cas de changement.</li>
      <li>Utiliser un design system pour homogénéiser les composants et gagner en cohérence.</li>
      <li>Réévaluer régulièrement le backlog et ajuster la planification en fonction des retours terrain.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>MOA</strong> (Maîtrise d’Ouvrage) & <strong>AMOA</strong> : valident la conception fonctionnelle et le planning.<br>
      • <strong>MOE</strong> (Maîtrise d’Œuvre) & <strong>Architectes logiciels</strong> : définissent la faisabilité et l’architecture.<br>
      • <strong>Chefs de projet</strong> : orchestrent la planification et les jalons.<br>
      • <strong>UX/UI Designers</strong> : élaborent et testent les prototypes.<br>
      • <strong>Développeurs</strong> : estiment les efforts et préparent les futurs sprints.
    </p>
  </section>
  
<!-- Développement -->
<section id="developpement" class="my-5">
    <h2>
      <img src="img/img-cycle/marteau.png" alt="icon developpement" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Développement
    </h2>
  
    <p>
      La phase de développement transforme les spécifications et prototypes en un produit exécutable. Les développeurs écrivent le code, intègrent les composants, et veillent à la robustesse et à la maintenabilité de l’application.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Implémenter les fonctionnalités</strong> définies dans le backlog et validées lors de la conception.</li>
      <li><strong>Assurer la qualité</strong> via des tests unitaires, d’intégration et fonctionnels.</li>
      <li><strong>Automatiser les builds</strong> et déploiements pour fiabiliser la chaîne de livraison.</li>
      <li><strong>Documenter le code</strong> et les API pour faciliter la maintenance future.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>Test-Driven Development (TDD)</strong> : écrire d’abord les tests puis le code pour les satisfaire.</li>
      <li><strong>Pair programming</strong> et revue de code (code review) pour partager la connaissance et détecter les bugs tôt.</li>
      <li><strong>Gestion de versions</strong> : stratégie Git (feature branches, pull requests, GitFlow ou trunk-based).</li>
      <li><strong>Intégration Continue (CI)</strong> : exécution automatique des tests et builds à chaque commit.</li>
      <li><strong>Développement itératif</strong> : livraisons fréquentes en petites itérations pour réduire le risque.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>Environnements de dev</strong> : VS Code, WebStorm, Visual Studio.</li>
      <li><strong>Gestion de code</strong> : Git + GitHub/GitLab/Bitbucket.</li>
      <li><strong>CI/CD</strong> : Jenkins, GitHub Actions, GitLab CI, CircleCI.</li>
      <li><strong>Conteneurs & virtualisation</strong> : Docker, Docker Compose.</li>
      <li><strong>Tests</strong> : Jest, Mocha, PHPUnit, Cypress pour les E2E.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Répertoire de code source</strong> avec structure de projet claire et README.</li>
      <li><strong>Pipelines CI/CD</strong> configurés et validés (build, tests, déploiements automatiques).</li>
      <li><strong>Rapports de tests</strong> (unitaires, couverture, performance).</li>
      <li><strong>Documentation technique</strong> : API, schémas d’architecture, guides de déploiement.</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Respecter les conventions de codage et linters (ESLint, PHP_CodeSniffer, etc.).</li>
      <li>Commits atomiques et messages clairs pour l’historique Git.</li>
      <li>Écrire des tests avant de développer les fonctionnalités critiques.</li>
      <li>Refactorer régulièrement pour éviter l’accumulation de dette technique.</li>
      <li>Utiliser des feature flags pour déployer du code en production de manière contrôlée.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>MOE</strong> (Maîtrise d’Œuvre) : organise et supervise la réalisation techniques.<br>
      • <strong>Développeurs</strong> : implémentent les fonctionnalités et écrivent les tests.<br>
      • <strong>Testeurs QA</strong> : conçoivent et exécutent les tests d’intégration et fonctionnels.<br>
      • <strong>DevOps</strong> : maintiennent les pipelines CI/CD et automatisent les déploiements.
    </p>
  </section>
  


<!-- Déploiement -->
<section id="deploiement" class="my-5">
    <h2>
      <img src="img/img-cycle/lancement-du-projet.png" alt="icon déploiement" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Déploiement
    </h2>
  
    <p>
      La phase de déploiement vise à rendre votre application disponible aux utilisateurs finaux, tout en garantissant sécurité, fiabilité et réversibilité en cas de besoin.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Mise en production</strong> : transférer le code et la configuration dans l’environnement live.</li>
      <li><strong>Minimiser les interruptions</strong> : déploiements blue/green ou canary pour assurer une transition transparente.</li>
      <li><strong>Assurer la stabilité</strong> : vérifier que tous les services démarrent correctement et que les dépendances sont saines.</li>
      <li><strong>Monitorer en temps réel</strong> : activer le logging, les métriques et les alertes pour détecter les anomalies.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>Pipeline CD</strong> : déclencher automatiquement le déploiement après validation CI (tests réussis).</li>
      <li><strong>Environnements multiples</strong> : préparer des environnements de staging, pré-production, puis production.</li>
      <li><strong>Stratégies de release</strong> : utiliser les déploiements progressifs (canary, rolling updates, blue/green).</li>
      <li><strong>Rollback plan</strong> : définir des procédures automatiques ou manuelles pour revenir à une version stable en cas de problème.</li>
      <li><strong>Validation post-déploiement</strong> : smoke tests et contrôles de santé (health checks) pour chaque service.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>CI/CD</strong> : GitHub Actions, GitLab CI, Jenkins, CircleCI, Azure DevOps.</li>
      <li><strong>Orchestration</strong> : Kubernetes, Docker Swarm, Nomad.</li>
      <li><strong>Infrastructure as Code</strong> : Terraform, Ansible, CloudFormation.</li>
      <li><strong>Monitoring & alerting</strong> : Prometheus, Grafana, ELK Stack, Datadog.</li>
      <li><strong>Load balancing</strong> : NGINX, HAProxy, AWS ELB.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Scripts et templates IaC</strong> pour provisionner l’infrastructure.</li>
      <li><strong>Configurations de pipeline CD</strong> documentées et versionnées.</li>
      <li><strong>Runbooks</strong> de déploiement et de rollback.</li>
      <li><strong>Rapports de validation</strong> après chaque étape (smoke tests, performance basique).</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Automatiser au maximum pour réduire les erreurs manuelles.</li>
      <li>Tester chaque modification dans un environnement de staging avant la prod.</li>
      <li>Versionner toutes les configurations et scripts IaC.</li>
      <li>Mettre en place des alertes basées sur les SLO/SLA (latence, erreurs, disponibilité).</li>
      <li>Prévoir des fenêtres de maintenance avec communication préalable si nécessaire.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>DevOps</strong> : conçoivent et maintiennent les pipelines de déploiement.<br>
      • <strong>Administrateurs système</strong> : gèrent la configuration serveurs et réseaux.<br>
      • <strong>Chefs de projet</strong> : coordonnent la planification et la communication des mises en production.<br>
      • <strong>Testeurs QA</strong> : exécutent les smoke tests et valident la version déployée.
    </p>
  </section>
  
<!-- Maintenance et évolutions -->
<section id="maintenance" class="my-5">
    <h2>
      <img src="img/img-cycle/maintenance.png" alt="icon maintenance" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Maintenance et évolutions
    </h2>
  
    <p>
      Une fois l’application en production, la maintenance vise à corriger les incidents et à sécuriser les mises à jour, tandis que les évolutions ajoutent de la valeur en répondant aux retours utilisateurs et aux nouveaux besoins métier.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Corriger les bugs</strong> : identifier et résoudre rapidement les incidents critiques.</li>
      <li><strong>Assurer la sécurité</strong> : appliquer les patches et mises à jour de dépendances.</li>
      <li><strong>Optimiser les performances</strong> : ajuster la configuration, mettre en cache les requêtes.</li>
      <li><strong>Faire évoluer les fonctionnalités</strong> : intégrer les feedbacks et ajouter de nouvelles options.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>SLA / SLA Techniques</strong> : définir les temps de réponse et de résolution par niveau de criticité.</li>
      <li><strong>Suivi des incidents</strong> : ticketing (Jira, Zendesk) avec triage et priorisation.</li>
      <li><strong>Patch management</strong> : planifier et tester les mises à jour en staging avant prod.</li>
      <li><strong>Collecte de feedback</strong> : sondages in-app, outils d’analytics, support technique.</li>
      <li><strong>Déploiement de nouvelles versions</strong> : suivre le même pipeline CD que pour la prod initiale.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>Issue tracker</strong> : Jira, GitLab Issues, Zendesk.</li>
      <li><strong>Monitoring & APM</strong> : New Relic, Datadog, Prometheus + Grafana.</li>
      <li><strong>Outils de SAST/DAST</strong> : SonarQube, OWASP ZAP pour détecter les nouvelles vulnérabilités.</li>
      <li><strong>CI/CD</strong> : conserver et réutiliser vos pipelines Jenkins, GitHub Actions, GitLab CI.</li>
      <li><strong>Analyse de logs</strong> : ELK Stack, Splunk pour diagnostiquer et corréler les incidents.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Rapports d’incidents</strong> et indicateurs MTTR (Mean Time To Repair).</li>
      <li><strong>Changelogs</strong> documentant chaque version et patch appliqué.</li>
      <li><strong>Tableaux de bord</strong> de performance et de disponibilité (uptime, temps de réponse).</li>
      <li><strong>Plan de release</strong> pour les évolutions majeures, avec rétroplanning.</li>
      <li><strong>Documentation utilisateur</strong> mise à jour (notes de version, guide d’utilisation).</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Automatiser la surveillance et les alertes pour prévenir avant l’impact utilisateur.</li>
      <li>Allouer un pourcentage fixe de capacité sprint à la maintenance et au refactoring.</li>
      <li>Valider chaque patch ou évolution en staging avec des tests automatisés et manuels.</li>
      <li>Tenir à jour le backlog d’incidents et prioriser selon la criticité et l’impact.</li>
      <li>Organiser des revues post-mortem après incidents majeurs pour améliorer le processus.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>Développeurs</strong> : corrigent les bugs et implémentent les évolutions.<br>
      • <strong>Testeurs QA</strong> : valident les correctifs et nouvelles fonctionnalités.<br>
      • <strong>Support technique</strong> : première ligne de contact et collecte des incidents.<br>
      • <strong>DevOps</strong> : gèrent le patch management et les remontées de monitoring.
    </p>
  </section>
  

<!-- Décommissionnement -->
<section id="decommissionnement" class="my-5">
    <h2>
      <img src="img/img-cycle/corbeille-a-papier.png" alt="icon decommissionnement" class="img-fluid"
           style="width: 64px; height: auto; margin-right: 20px; vertical-align: middle;">
      Décommissionnement
    </h2>
  
    <p>
      Le décommissionnement marque la fin de vie d’une application ou d’un service. Cette phase organise l’arrêt contrôlé, la migration éventuelle et la mise en conformité pour éviter toute perte de données et garantir la continuité pour les utilisateurs.
    </p>
  
    <h3>Objectifs de la phase</h3>
    <ul>
      <li><strong>Assurer une transition fluide</strong> : migrer les utilisateurs et données sans coupure de service.</li>
      <li><strong>Garantir la conformité</strong> : respecter les obligations légales (RGPD, archivage réglementaire).</li>
      <li><strong>Optimiser les ressources</strong> : libérer l’infrastructure pour réduire les coûts.</li>
      <li><strong>Capitaliser</strong> : analyser les enseignements et bonnes pratiques du projet.</li>
    </ul>
  
    <h3>Méthodologie</h3>
    <ul>
      <li><strong>Plan de migration</strong> : définir étapes, calendriers et responsabilités pour transférer les données et utilisateurs.</li>
      <li><strong>Archivage sécurisé</strong> : extraire, chiffrer et stocker les données selon la politique de rétention.</li>
      <li><strong>Communication</strong> : informer les parties prenantes, clients et support des échéances et modalités.</li>
      <li><strong>Audit post-mortem</strong> : organiser un retour d’expérience pour identifier succès et points d’amélioration.</li>
      <li><strong>Nettoyage d’environnement</strong> : détruire ou réaffecter les serveurs, conteneurs et bases de test.</li>
    </ul>
  
    <h3>Outils recommandés</h3>
    <ul>
      <li><strong>Scripts d’export</strong> et ETL (Talend, Pentaho) pour extraire et transformer les données.</li>
      <li><strong>Stockage d’archives</strong> : AWS S3 Glacier, Azure Archive Storage, NAS chiffré.</li>
      <li><strong>Outils de communication</strong> : email, Slack, notifications in-app pour informer les utilisateurs.</li>
      <li><strong>Gestion de projet</strong> : Jira / Trello pour suivre les tâches de migration et d’arrêt.</li>
      <li><strong>Outils de reporting</strong> : Power BI, Grafana pour consolider les leçons tirées.</li>
    </ul>
  
    <h3>Livrables clés</h3>
    <ul>
      <li><strong>Plan de transition</strong> documenté (étapes, calendrier, rollback).</li>
      <li><strong>Archives chiffrées</strong> avec index et métadonnées pour restauration éventuelle.</li>
      <li><strong>Rapport d’audit post-mortem</strong> résumant le bilan fonctionnel, technique et financier.</li>
      <li><strong>Tâches de nettoyage</strong> validées (suppression des environnements, des accès).</li>
      <li><strong>Guide de restitution</strong> destiné aux équipes support et opérations.</li>
    </ul>
  
    <h3>Bonnes pratiques</h3>
    <ul>
      <li>Planifier le décommissionnement dès la conception initiale pour anticiper les impacts.</li>
      <li>Mettre en place des jalons de validation à chaque étape de la migration.</li>
      <li>Maintenir une traçabilité exhaustive des données archivées.</li>
      <li>Vérifier la conformité RGPD avant toute suppression définitive.</li>
      <li>Documenter les retours d’expérience et mettre à jour le référentiel de bonnes pratiques.</li>
    </ul>
  
    <p>
      <strong>Acteurs :</strong><br>
      • <strong>Chefs de projet</strong> : planification et coordination du processus.<br>
      • <strong>Administrateurs système</strong> : exécution des scripts d’export, nettoyage d’infrastructure.<br>
      • <strong>Équipes légales</strong> : validation de la conformité et des politiques de rétention.<br>
      • <strong>Support technique</strong> : accompagnement des utilisateurs et gestion des incidents résiduels.
    </p>
  </section>
  


        </div>




        </div>

        <article id="item3">
            <h2>Illustrations et cas pratiques
            </h2><br>
            <h3>3.a Exemple concret du cycle de vie d’un site e-commerce</h3>

            <p><strong>Après les phases de recherche de contenus (textes et visuels) puis l’élaboration d’un plan de
                    site avec sa structure :</strong></p><br>

            <div class="row">
                <div class="col-md-6">
                    <ol>
                        <li>Choisir un nom de domaine et un hébergeur de qualité</li><br>
                        <li>Développement & Conception du site</li><br>
                        <li>Phases de test en développement</li><br>
                        <li>Mise en ligne du site</li><br>
                        <li>Nouveaux tests après la mise en production du site</li><br>
                        <li>Faire connaître son site dans les moteurs de recherche (SEO)</li><br>
                        <li>Lier son site aux réseaux sociaux</li><br>
                    </ol>
                </div>
                <div class="col-md-6">
                    <ol start="8">
                        <li>Actualiser son site, faire vivre son site, ajouter de nouveaux contenus régulièrement</li>
                        <br>
                        <li>Faire la maintenance de son site : mises à jour techniques et suivi rigoureux</li><br>
                        <li>Après deux ans, faire des évolutions sur son site Internet</li><br>
                        <li>Mettre à jour les contenus, toujours travailler son référencement</li><br>
                        <li>Après trois ans, faire une mise à jour majeure du site</li><br>
                        <li>Après quatre ans, penser à la refonte du site Internet</li><br>
                        <li>À 5 ans, un nouveau cycle de vie commence après la refonte</li><br>
                    </ol>
                </div>
            </div>
            <div class="container text-center mt-5">
                <p><strong>Cycle de vie d'un site e-commerce</strong></p>
                <div class="d-flex justify-content-center mt-4">
                    <img src="img/img-cycle/cycledevie.webp" class="img-thumbnail" alt="Cycle de vie"
                        style="max-width: 50vw; cursor: pointer;" data-bs-toggle="modal" data-bs-target="#imageModal">
                </div>
            </div>

            <!-- Modale pour zoomer en plein écran -->
            <div class="modal fade" id="imageModal" tabindex="-1" aria-labelledby="imageModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-fullscreen">
                    <div class="modal-content">
                        <div class="modal-header border-0">
                            <button type="button" class="btn-close" data-bs-dismiss="modal"
                                aria-label="Fermer"></button>
                        </div>
                        <div class="modal-body d-flex justify-content-center align-items-center p-0">
                            <img src="img/img-cycle/cycledevie.webp" class="img-fluid" alt="Cycle de vie"
                                style="width: 100vw; height: 100vh; object-fit: contain;">
                        </div>
                    </div>
                </div>
            </div>
            <br><br>
            <h3>3b. Les principaux écueils d’un cycle de vie mal maîtrisé</h3><br><br>

            <div class="row">
                <div class="col-md-6">
                    <ol>
                        <li>Isoler un projet Web de la stratégie de l’entreprise le condamne à l’échec, car celui-ci est
                            l’extension de la stratégie de l’entreprise.</li><br>
                        <li>Un projet informatique est très souvent sous-estimé et dérive quasi systématiquement. C’est
                            pourquoi il est indispensable de planifier la conception d’un vrai MVP (Minimum Viable
                            Product) pour éprouver le cœur du projet. Cela permet par exemple d’éviter de développer de
                            grandes fonctionnalités qui se révèlent être inutiles.</li><br>
                        <li>Le manque de tests est un autre écueil en matière de développement. Ils sont souvent mis de
                            côté en raison de contraintes de temps ou de budget. Selon une étude de Google, environ 60 %
                            des utilisateurs supprimeront une application mobile ou quitteront un site web mobile après
                            une seule expérience décevante.</li><br>
                    </ol>
                </div>
                <div class="col-md-6">
                    <ol start="4">
                        <li>Il faut savoir terminer un projet : on peut être tenté de vouloir avoir le « site parfait »
                            pour la mise en ligne. Pourtant, en faisant cela, on ne fait que retarder cette mise en
                            ligne. Il vaut mieux phaser l’implémentation de nouvelles fonctionnalités et profiter d’une
                            présence en ligne plus tôt.</li><br>
                        <li>Une mauvaise communication entre les équipes de développement peut être préjudiciable : on
                            peut ainsi assister au cloisonnement des équipes en charge des applications, du réseau et de
                            la sécurité.</li>
                    </ol>
                </div>
            </div>
            <br><br>



            <article id="item4">
                <h2>Conclusion</h2><br>
                <h3>Synthèse et importance de chaque phase</h3>
                <p><strong>Le cycle de vie d’une application web est composé d’étapes distinctes et complémentaires,
                        chacune essentielle à la réussite globale du projet.</strong></p>
                <div class="row">
                    <ul class="col-md-6">
                        <li><strong>Analyse des besoins :</strong> permet de cerner précisément les attentes et les
                            contraintes, constituant la base solide du projet.</li>
                        <li><strong>Conception et planification :</strong> garantit que l’architecture et les choix
                            technologiques soient adaptés et viables à long terme.</li>
                        <li><strong>Développement :</strong> renforcé par des tests et une intégration continue, assure
                            la qualité et la robustesse du produit.</li>
                    </ul>
                    <ul class="col-md-6">
                        <li><strong>Déploiement :</strong> doit être minutieusement exécuté afin d’assurer la stabilité
                            et la sécurité de l’application en production.</li>
                        <li><strong>Maintenance et évolutions :</strong> permettent d’adapter continuellement
                            l’application aux besoins changeants et d'assurer sa pérennité.</li>
                        <li><strong>Décommissionnement :</strong> joue un rôle crucial dans la gestion responsable des
                            ressources et la sécurité des données.</li>
                    </ul>
                </div>
                <p>La négligence d'une seule de ces phases peut avoir des conséquences graves sur la qualité finale de
                    l’application, sur l’expérience utilisateur, mais aussi sur la viabilité économique du projet.</p>
                <br>

                <h3>Meilleures pratiques pour optimiser le cycle de vie</h3>
                <p><strong>Pour optimiser le cycle de vie d'une application web, il est conseillé d'adopter les
                        meilleures pratiques suivantes :</strong></p>
                <div class="row">
                    <ol class="col-md-6">
                        <li><strong>Gestion rigoureuse du projet :</strong> Utiliser des méthodologies telles qu’Agile
                            ou Scrum pour faciliter la flexibilité et améliorer la réactivité face aux changements.</li>
                        <li><strong>Documentation exhaustive :</strong> Maintenir une documentation claire et actualisée
                            à chaque phase pour faciliter la communication entre équipes et assurer la continuité des
                            connaissances.</li>
                        <li><strong>Automatisation et intégration continue (CI/CD) :</strong> Mettre en place des
                            processus automatisés de tests et de déploiement pour réduire les erreurs humaines et
                            accélérer les mises en production.</li>
                    </ol>
                    <ol class="col-md-6">
                        <li><strong>Monitoring et veille technique :</strong> Surveiller régulièrement les performances
                            et la sécurité de l’application pour identifier rapidement les problèmes et anticiper les
                            risques.</li>
                        <li><strong>Approche centrée utilisateur :</strong> Impliquer les utilisateurs finaux tout au
                            long du cycle, particulièrement lors des phases de conception et de validation, pour
                            s’assurer que l’application répond efficacement à leurs attentes.</li>
                        <li><strong>Planification stratégique du décommissionnement :</strong> Préparer dès le départ
                            une stratégie de sortie ou de migration afin d’assurer une transition fluide et sécurisée en
                            fin de vie de l'application.</li>
                    </ol>
                </div>
                <p>En suivant ces bonnes pratiques, les équipes peuvent garantir une meilleure maîtrise du cycle de vie
                    de leurs applications, maximiser leur valeur ajoutée et assurer leur succès à long terme.</p>
            </article>
    </main>
    <!-- BACK TO TOP -->
    <nav class="sub-navbar navbar navbar-expand bg-secondary py-1">
        <div class="container d-flex justify-content-center">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link text-white" href="#top">Début de page</a></li>
            </ul>
        </div>
    </nav>
    <!-- Bootstrap Bundle JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <script src="main.js"></script>
    <script>
        const container = document.querySelector('.scrollable-container');
        const timeline = container.querySelector('.timeline');
        // on récupère dynamiquement la hauteur + margin + top
        const topOffset = timeline.offsetHeight
            + parseFloat(getComputedStyle(timeline).marginBottom)
            + parseFloat(getComputedStyle(timeline).top);

        container.querySelectorAll('.timeline-item').forEach(item => {
            item.addEventListener('click', e => {
                e.preventDefault();
                const targetEl = document.getElementById(item.dataset.target);
                if (!targetEl) return;

                const containerRect = container.getBoundingClientRect();
                const targetRect = targetEl.getBoundingClientRect();

                // position brute dans le conteneur
                const scrollY = (targetRect.top - containerRect.top) + container.scrollTop;

                // on enlève le topOffset pour que le titre n’aille pas sous la frise
                container.scrollTo({
                    top: scrollY - topOffset,
                    behavior: 'smooth'
                });
            });
        });
    </script>
  <script>
    document.querySelectorAll('.role-card.clickable').forEach(card => {
      card.addEventListener('click', () => {
        const title = card.getAttribute('data-title');
        const tmpl = document.getElementById(`tmpl-${card.getAttribute('data-template')}`);
        if (!tmpl) return;
        document.getElementById('processModalLabel').textContent = title;
        document.getElementById('processModalContent').innerHTML = tmpl.innerHTML;
        new bootstrap.Modal(document.getElementById('processModal')).show();
      });
    });
  </script>
  
</body>

</html>